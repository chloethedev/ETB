"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const taquito_1 = require("@taquito/taquito"); //TODO: once taquito parsing/encoding arg bug fixed
//import { Tezos } from '@tezos-ts/tezos-ts';
exports.TezosDefinition = {
    initNetworkType(web3, options) {
        return __awaiter(this, void 0, void 0, function* () {
            overrides.getId(web3);
            overrides.getAccounts(web3, options);
            overrides.getBlock(web3);
            overrides.getBlockNumber(web3);
            overrides.getBalance(web3);
        });
    }
};
const overrides = {
    getId: (web3) => {
        // here we define a tez namespace &
        // attach our Tezos provider to the Web3Shim
        web3.tez = taquito_1.Tezos;
        const _oldGetId = web3.eth.net.getId;
        web3.eth.net.getId = () => __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore (typings incomplete)
            const currentHost = web3.currentProvider.host;
            // web3 has some neat quirks
            const parsedHost = currentHost.match(/(^https?:\/\/)(.*?)\:\d.*/)[2];
            // sets the provider for subsequent Tezos provider calls
            yield web3.tez.setProvider({ rpc: parsedHost });
            // @ts-ignore (typings incomplete)
            const { chainId } = yield web3.tez.rpc.getBlockHeader();
            return chainId;
        });
    },
    getAccounts: (web3, { config }) => {
        const _oldGetAccounts = web3.eth.getAccounts;
        web3.eth.getAccounts = () => __awaiter(this, void 0, void 0, function* () {
            // here we import user's faucet account:
            // email, passphrase, mnemonic, & secret are all REQUIRED.
            // TODO: all logic to check if user is importing only a private secret key
            // that would unlock the account, or a psk w/ passphrase
            let mnemonic = config.networks[config.network].mnemonic;
            if (Array.isArray(mnemonic))
                mnemonic = mnemonic.join(" ");
            yield web3.tez.importKey(config.networks[config.network].email, config.networks[config.network].passphrase, mnemonic, config.networks[config.network].secret);
            const currentAccount = yield web3.tez.signer.publicKeyHash();
            return [currentAccount];
        });
    },
    getBlock: (web3) => {
        const _oldGetBlock = web3.eth.getBlock;
        // @ts-ignore
        web3.eth.getBlock = (blockNumber = "head") => __awaiter(this, void 0, void 0, function* () {
            // translate ETH nomenclature to XTZa
            // @ts-ignore
            if (blockNumber === "latest")
                blockNumber = "head";
            const { hardGasLimitPerBlock } = yield web3.tez.rpc.getConstants();
            const block = yield web3.tez.rpc.getBlockHeader({ block: `${blockNumber}` });
            // @ts-ignore
            block.gasLimit = hardGasLimitPerBlock;
            return block;
        });
    },
    getBlockNumber: (web3) => {
        const _oldGetBlockNumber = web3.eth.getBlockNumber;
        web3.eth.getBlockNumber = () => __awaiter(this, void 0, void 0, function* () {
            const { level } = yield web3.tez.rpc.getBlockHeader();
            return level;
        });
    },
    getBalance: (web3) => {
        // since this is used in the tez reporter,
        // decided to namespace a specific tez getBalance method
        // @ts-ignore
        web3.tez.getBalance = (address) => __awaiter(this, void 0, void 0, function* () {
            const balance = (yield web3.tez.tz.getBalance(address)).toString();
            return balance;
        });
    }
};
//# sourceMappingURL=tezos-overloads.js.map